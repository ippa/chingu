= CHINGU
http://github.com/ippa/chingu/tree/master

DOCUMENTATION: http://rdoc.info/projects/ippa/chingu

This is an early preview, a lot of functionality is still missing!
It's also in a state of flux while I decide on core-naming etc.

== INSTALL
  gem sources -a http://gems.github.com
  sudo gem install ippa-chingu


== DESCRIPTION
Game framework built on top of the OpenGL accelerated game lib Gosu. 
It adds simple yet powerfull game states, prettier inputhandling, deploymentsafe asset-handling, a basic re-usable game object and automation of common task.


== THE STORY
The last years I've dabbled around a lot with game development.
I've developed games in both Rubygame and Gosu. I've looked at gamebox.
Rubygame is a very capable framework with a lot of functionality (collision detection, very good event system etc). Gosu is way more minimalistic but also faster with OpenGL -acceleration. Gosu isn't likely to get much more complex since it does what it should do very well and fast.

After 10+ game prototypes and some finished smaller games I started to see patterns each time I started a new game. Making classes with x/y/image/other-parameters that I called update/draw on in the main loop. This became the basic Chingu::GameObject which encapsulates Gosus "Image.draw_rot" and enables automatic updating/drawing.

There was always a huge big chunk of checking keyboard-events in the main loop.
Borrowing ideas from Rubygame this has now become @player.keyboard(:left => :move_left, :space => :fire ... etc.


== OVERVIEW
Chingu consists of the following core classes:

=== Chingu::Window
The main window, use it at you use Gosu::Window.

=== Chingu::GameObject
Use for your in game objects, got everything to put them on the screen.
Has either Chingu::Window or a Chingu::GameState as "owner".

=== Chingu::Text
Makes use of Gosu::Font more rubyish and powerful

=== Chingu::GameState
A "standalone game loop" that can be switched on/off to control game flow.

=== Chingu::GameStateManager
Keeps track of the game states. The flow of draw/update/button_down is Chingu::Window --> Chingu::GameStateManager --> Chingu::GameState.

== THE BASICS

=== Chingu::Window
With Gosu the main window inherits from Gosu::Window. In Chingu we use Chingu::Window. It's a basic Gosu::Window with extra cheese on top of it. keyboard handling, automatic update/draw calls to all gameobjects, fps counting etc.

You're probably familiar with this very common Gosu pattern:
  
  ROOT_PATH = File.dirname(File.expand_path(__FILE__))
  class Game < Gosu::Window
    def initialize
      @player = Player.new
    end
    
    def update
      if button_down? Button::KbLeft
        @player.left
      elsif button_down? Button::KbRight
        @player.right
      end
      
      @player.update      
    end
    
    def draw
      @player.draw
    end
  end
  
  class Player
    attr_accessor :x,:y,:image
    def initialize(options)
      @x = options[:x]
      @y = options[:y]
      @image = Image.new(File.join(ROOT_PATH, "media", "player.png"))
    end
    
    def move_left
      @x -= 1
    end
    
    def move_right
      @x += 1
    end
    
    def draw
      @image.draw(@x,@y,100)
    end
  end
  
  Game.new.show   # Start the Game update/draw loop!


Chingu doesn't change any fundamental concept of Gosu, but it will make the above code cleaner:
  
  #
  # We use Chingu::Window instead of Gosu::Window
  #
  class Game < Chingu:Window
    def initialize
      super       # This is always needed if you want to take advantage of what chingu offers
      #
      # Player will automaticly be updated and drawn since it's a Chingu::GameObject
      # You'll need your own Game#update/#draw after a while, but just put #super there and Chingu can do its thing.
      #
      @player = Player.new
      @player.input = {:left => :move_left, :right => :move_right}
    end    
  end
    
  #
  # If we create classes from Chingu::GameObject we get stuff for free.
  # The accessors: image,x,y,zorder,angle,factor_x,factor_y,center_x,center_y,mode,update,draw
  # You might recognize those from #draw_rot - http://www.libgosu.org/rdoc/classes/Gosu/Image.html#M000023
  # And in it's core, that's what Chingu::GameObject is, an encapsulation of draw_rot with some extra cheese.
  # For example, we get automatic calls to draw/update with Chingu::GameObject, which usually is what you want. 
  # You could stop this by doing: @player = Player.new(:draw => false, :update => false)
  #
  class Player < Chingu::GameObject
    def initialize(options)
      super(options.merge(:image => Image["player.png"])
    end
    
    def move_left
      @x -= 1
    end
    
    def move_right
      @x += 1
    end    
  end

  Game.new.show   # Start the Game update/draw loop!
  
Roughly 50 lines became 26 more powerful lines. (you can do @player.angle = 100 for example)

If you've worked with Gosu for a while you're probably tired of passing around the window-parameter.
Chingu solves this (as has many other developers) with a global variable $window. Yes, globals are bad, but in this case it kinda makes sense. It's used under the hood in various places.

=== Chingu::GameObject
This is our basic "game unit"-class, meaning most in game objects (players, enemies, bullets etc) should be inherited from Chingu::GameObject. The basic ideas behind it are:

* Encapsulate only the very common basics that Most in game objects need
* Keep naming close to Gosu, but add smart convenient methods / shortcuts and a more rubyish feeling
* No game logic allowed in GameObject, since that's not likely to be useful for others.

I've chose to base it around Image#draw_rot. So basically all the arguments that you pass to draw_rot can be passed to GameObject#new when creating a new object, an example using almost all arguments would be:
  
  #
  # You probably recognize the arguments from http://www.libgosu.org/rdoc/classes/Gosu/Image.html#M000023
  #
  @player = Player.new(:image => Image["player.png"], :x=>100, :y=>100, :zorder=>100, :angle=>45, :factor_x=>10, :factor_y=>10, :center_x=>0, :center_y=>0)
  
  #
  # A shortcut for the above line would be
  #
  @player = Player.new(:image => Image["player.png"], :x=>100, :y=>100, :zorder=>100, :angle=>45, :factor=>10, :center=>0)

  #
  # I've tried doing sensible defaults:
  # x/y = [middle of the screen]  for super quick display where it should be easy in sight)
  # angle = 0                     (no angle by default)
  # center_x/center_y = 0.5       (basically the center of the image will be drawn at x/y)
  # factor_x/factor_y = 1         (no zoom by default)
  # 
  @player = Player.new
  
  #
  # By default Chingu::Window calls update & draw on all GameObjects in it's own update/draw.
  # If this is not what you want, use :draw and :update
  #
  @player = Player.new(:draw => false, :update => false)

=== Input
One of the core things I wanted a more natural way of inputhandling.
You can define input -> actions on Chingu::Window, Chingu::GameState and Chingu::GameObject.
Like this:

  #
  # When left arrow is pressed, call @player.turn_left ... and so on.
  #
  @player.input = { :left => :turn_left, :right => :turn_right, :left => :halt_left, :right => :halt_right }

  
  #
  # In Gosu the equivalent would be:
  #
  def button_down(id)
    @player.turn_left		if id == Button::KbLeft
    @player.turn_right	if id == Button::KbRight
  end
  
  def button_up(id)
    @player.halt_left		if id == Button::KbLeft
    @player.halt_right	if id == Button::KbRight
  end


Another more complex example:

  #
  # So what happens here?
  #
  # Pressing P would create an game state out of class Pause, cache it and activate it.
  # Pressing ESC would call Play#close
  # Holding down LEFT would call Play#move_left on every game iteration
  # Holding down RIGHT would call Play#move_right on every game iteration
  # Relasing SPACE would call Play#fire
  #
  
  class Play < Chingu::GameState
    def initialize
      self.input = { :p => Pause, :escape => :close, :holding_left => :move_left, :holding_right => :move_right, :released_space => :fire }
    end
  end
  class Pause < Chingu::GameState
    # pause logic here
  end

In Gosu the above code would include code in button_up(), button_down() and a check for button_down?() in update().

Every symbol can be prefixed by either "released_" or "holding_" while no prefix at all defaults to pressed once.
So, why not :up_space or :relase_space instead of :released_space?
Or :hold_left or :down_left instead of :holding_left?

:up_space doesn't sound like english, :release_space sounds more like a command then an event.

:holding_left sounds like something that's happening over a period of time, not a single trigger, which corresponds good to what's happening when using it.

And with the default :space => :something youd imagine that :something is called once. You press :space once, :something get's executed once.


=== GameState / GameStateManager
Chingu incorporates a basic push/pop game state system (as discussed here: http://www.gamedev.net/community/forums/topic.asp?topic_id=477320).

Game states is a way of organizing your intros, menus, levels.

Game states aren't complicated. In Chingu a GameState is a class that behaves mostly like your default Gosu::Window (or in our case Chingu::Window) game loop.

  
  # A simple GameState-example
  class Intro < Chingu::GameState
  
    def update
      # game logic here
    end
    
    def draw
      # screen manipulation here
    end
        
    # Called when we enter the game state
    def setup
      @player.angle = 0   # point player upwards
    end
    
    # Called when we leave the current game state
    def finalize
      push_game_state(Menu)   # switch to game state "Menu"
    end

  end

Looks familiar ye?
You can activate the above game state in 2 ways

  class Game < Chingu::Window
    def initialize
      #
      # 1) Create a new Intro-object and activate it (pushing to the top).
      # This version makes more sense if you want to pass parameters to the gamestate, for example:
      # push_game_state(Level.new(:level_nr => 10))
      #
      push_game_state(Intro.new)
      
      #
      # 2) This leaves the actual object-creation to the game state manager.
      # This results in only 1 object is ever created of class 'Intro'.
      # The second time 'push_game_state(Intro)' is called, it will re-use the last one.
      # This means code in Intro#initialize() is only  called once, Intro#setup() is called everytime Intro is activated though.
      #
      push_game_state(Intro)
    end
  end
  
A GameState in Chingu is just a class with the following instance methods: 

* initialize()  - called only once with push_game_state(Intro) but everytime with push_game_state(Intro.new)
* setup()       - called each time the game state becomes active. 
* button_down(id) - Called when a button is down
* button_up(id)   - Called when a button is released
* update()    - just as in your normal game loop, put your game logic here.
* draw()      - just as in your normal game loop, put your screen manipulation here.
* finalize()  - called when a game state de-activated (for example by pushing a new one on top with push_game_state)

Chingu::Window automatically creates a @game_state_manager and makes it accessible in our game loop.
By default the game loop calls update() / draw() on the the current game state.

Chingu also has a couple of helpers-methods for handling the game states:
In a main loop or in a game state:
* push_game_state(state)        - adds a new gamestate on top of the stack, which then becomes the active one
* pop_game_state                - removes active gamestate and activates the previous one
* current_game_state            - returns the current game state
* previous_game_state           - returns the previous game state (useful for pausing and dialog boxes, see example4.rb)
* pop_until_game_state(state)   - pop game states until given state is found
* clear_game_states             - removes all game states from stack

To switch to a certain gamestate with a keypress use Chingus input handler:
  class Intro < Chingu::GameState
    def setup
      self.input = { :space => lambda{push_gamestate(Menu.new)} }
    end
  end
  
Or Chingus shortcut:

  class Intro < Chingu::GameState
    def setup
      self.input = { :space => Menu }      #  or { :space => Menu.new } if you want to create a new object each time.
    end
  end

Chingus inputhandler will detect that Menu is a gamestate-class, create a new instance, cache it and activate it with push_game_state().

=== Assets / Paths

You might wonder why this is nessesary in the straight Gosu example:
  ROOT_PATH = File.dirname(File.expand_path(__FILE__))
  @image = Image.new(File.join(ROOT_PATH, "media", "player.png"))

It enables you to start your game from any directory and it will still find your assets (pictures, samples, fonts etc..) correctly.
For a local development version this might not be important, you're likely to start the game from the games root-dir.
But as soon as you try to deploy (for example to windows with OCRA - http://github.com/larsch/ocra/tree/master) you'll run into trouble of you dont do it like that.
 
Chingu solves this problem behind the scenes for the most common assets. The 2 lines above can be replaced with:
Image["player.png"]

You also have Sound["player.png"]

Tiles and fonts are trickier since they require extra parameters so you'll have to do those the ordinary way.
You'll get $window.root (equivalent to ROOT_PATH above) for free though which points to the dir containing the game.

=== Text
Text is a class to give the use of Gosu::Font more rubyish feel and fit it better into Chingu.

# Pure Gosu
  @font = Gosu::Font.new($window, "verdana", 30)
  @font.draw("A Text", 200, 50, 55, 2.0)
  
# Chingu
  @text = Chingu::Text.new(:text => "A Text", :x => 200, :y => 50, :zorder => 55, :factor_x => 2.0)
  @text.draw

@text.draw is usually not needed as Text is a GameObject and therefore autodrawn.
It's not only that the second example is readable by ppl now even familiar with Gosu, @text comes with a number of changeable properties, x,y,zorder,angle,factor_x,color,mode etc. Set a new x or angle or color and it will instantly update on screen.


== TODO:
* (done) Complete the input-definitions with all possible inputs (keyboard, gamepad, mouse)!
* Complete input-stuff with released-states etc
* More gfx effects, for example: fade in/out to a specific color (black makes sense between levels).
* (posted request on forums) Summon good proven community gosu snippets into Chingu
* (done) Generate docs @ ippa.github.com-  http://rdoc.info/projects/ippa/chingu !
* (done) A good scene-manager to manage welcome screens, levels and game flow- GameStateManager / GameState !
* More docs
* make a playable simple game in examples\ that really depends on game states
* (done) Make a gem- first gem made on github
* Automate gemgenning rake-task even more
* More examples when effects are more complete
* class ChipmunkObject
* class Actor/MovingActor with maybe abit more logic then the basic GameObject. Would ppl find is useful?
* Spell check all docs, sloppy spelling turns ppl off.
* Tests
* Streamline fps / tick code
* (done) Encapsulate Font.new / draw_rot with a "class Text < GameObject"
* Make it possible for ppl to use the parts of Chingu they like
* A more robust game state <-> game_object system to connect them together.
* Get better at styling rdocs
* all “gamestate” ? “game state” ?
* FIX example4: :p => Pause.new  would Change the "inside_game_state" to Pause and make @player belong to Pause.
* intergrate rubygame_movie_make (maybe after a rename, GameAutomator? GameSequence?

== WHY?
* Plain Gosu is very minimalistic, perfect to build some higher level logic on!
* Deployment and asset handling should be simple
* Managing game states/scenes (intros, menus, levels etc) should be simple
* There are patterns in game development

== OPINIONS
* Less code is usually better
* Hash arguments FTW. And it becomes even better in 1.9.
* Don't separate too much from Gosus core-naming

== CREDITS:
Jacius of Rubygame (For doing cool stuff that's well documented as re-usable). So far rect.rb and named_resource.rb is taken from Rubygame.

jlnr,philymore,shawn24 for constructive feedback


== REQUIREMENTS:
* Gosu latest version
* Ruby 1.8 (Has not been verified with 1.9 yet)
