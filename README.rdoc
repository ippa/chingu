= CHINGU
SOURCE: http://github.com/ippa/chingu/tree/master
DOCUMENTATION: http://rdoc.info/projects/ippa/chingu

This is a early preview, a lot of functionality is still missing!

== DESCRIPTION
Game framework built on top of the OpenGL accelerated game lib Gosu. "Chingu" means "Friend" in Korean.

== THE STORY
The last years I've dabbled around a lot with game development.
I've developed games in both Rubygame and Gosu. I've looked at gamebox.
Rubygame is a very capable framework with a lot of functionality (collision detection, very good event system etc). Gosu is way more minimalistic but also faster with OpenGL -acceleration. Gosu isn't likely to get much more complex since it does what it should do very well and fast.

After 10+ game prototypes and some finished smaller games I started to see patterns each time I started a new game. Making classes with x/y/image/other-parameters that I called update/draw on in the main loop. This became the basic Chingu::GameObject which encapsulates Gosus "Image.draw_rot" and enables automatic updating/drawing.

There was always a huge big chunk of checking keyboard-events in the main loop.
Borrowing ideas from Rubygame this has now become @player.keyboard(:left => :move_left, :space => :fire ... etc.

== OVERVIEW
Chingu consists of the following core classes:

=== Chingu::Window
The main window, use it at you use Gosu::Window.

=== Chingu::GameObject
Use for your in game objects, got everything to put them on the screen.
Has either Chingu::Window or a Chingu::GameState as "owner".

=== Chingu::Text
Makes use of Gosu::Font more rubyish and powerful

=== Chingu::GameState
A "standalone game loop" that can be switched on/off to control game flow.

=== Chingu::GameStateManager
Keeps track of the game states. The flow of draw/update/button_down is Chingu::Window --> Chingu::GameStateManager --> Chingu::GameState.

== THE BASICS

=== Chingu::Window
With Gosu the main window inherits from Gosu::Window. In Chingu we use Chingu::Window. It's a basic Gosu::Window with extra cheese on top of it. keyboard handling, automatic update/draw calls to all gameobjects, fps counting etc.

You're probably familiar with this very common Gosu pattern:
  
  ROOT_PATH = File.dirname(File.expand_path(__FILE__))
  class Game < Gosu::Window
    def initialize
      @player = Player.new
    end
    
    def update
      if button_down? Button::KbLeft
        @player.left
      elsif button_down? Button::KbRight
        @player.right
      end
      
      @player.update      
    end
    
    def draw
      @player.draw
    end
  end
  
  class Player
    attr_accessor :x,:y,:image
    def initialize(options)
      @x = options[:x]
      @y = options[:y]
      @image = Image.new(File.join(ROOT_PATH, "media", "player.png"))
    end
    
    def move_left
      @x -= 1
    end
    
    def move_right
      @x += 1
    end
    
    def draw
      @image.draw(@x,@y,100)
    end
  end
  
  Game.new.show   # Start the Game update/draw loop!


Chingu doesn't change any fundamental concept of Gosu, but it will make the above code cleaner:
  
  #
  # We use Chingu::Window instead of Gosu::Window
  #
  class Game < Chingu:Window
    def initialize
      super # This is always needed
      #
      # Player will automaticly be updated and drawn since it's a Chingu::GameObject
      # You'll need your own Game#update/#draw after a while, but just put #super there and Chingu can do its thing!
      #
      @player = Player.new
      @player.keymap = {:left => :move_left, :right => :move_right}
    end    
  end
    
  #
  # If we create classes from Chingu::GameObject we get stuff for free.
  # The accessors: image,x,y,zorder,angle,factor_x,factor_y,center_x,center_y,mode,update,draw
  # You might recognize those from #draw_rot - http://www.libgosu.org/rdoc/classes/Gosu/Image.html#M000023
  # And in it's core, that's what Chingu::GameObject is, an encapsulation of draw_rot with some extra cheese.
  # For example, we get automatic calls to draw/update with Chingu::GameObject, which usually is what you want. 
  # You could stop this by doing: @player = Player.new(:draw => false, :update => false)
  #
  class Player < Chingu::GameObject
    def initialize(options)
      super(options.merge(:image => Image["player.png"])
    end
    
    def move_left
      @x -= 1
    end
    
    def move_right
      @x += 1
    end    
  end

  Game.new.show   # Start the Game update/draw loop!
  
Roughly 50 lines became 26 more powerful lines. (you can do @player.angle = 100 for example)

If you've worked with Gosu for a while you're probably tired of passing around the window-parameter.
Chingu solves this (as has many other developers) with a global variable $window. Yes, globals are bad, but in this case it kinda makes sense. It's used under the hood in various places.

=== Chingu::GameObject
This is our basic "game unit"-class, meaning most in game objects (players, enemies, bullets etc) should be inherited from Chingu::GameObject. The basic ideas behind it are:

* Encapsulate only the very common basics that Most in game objects need
* Keep naming close to Gosu, but add smart convenient methods / shortcuts and a more rubyish feeling
* No game logic at all allowed in GameObject, since that is most likely useful for others

I've chose to base it around Image#draw_rot. So basically all the arguments that you pass to draw_rot can be passed to GameObject#new when creating a new object, an example using almost all arguments would be:
  
  #
  # You probably recognize the arguments from http://www.libgosu.org/rdoc/classes/Gosu/Image.html#M000023
  #
  @player = Player.new(:image => Image["player.png"], :x=>100, :y=>100, :zorder=>100, :angle=>45, :factor_x=>10, :factor_y=>10, :center_x=>0, :center_y=>0)
  
  #
  # A shortcut for the above line would be
  #
  @player = Player.new(:image => Image["player.png"], :x=>100, :y=>100, :zorder=>100, :angle=>45, :factor=>10, :center=>0)

  #
  # I've tried doing sensible defaults:
  # x/y = [middle of the screen]  for super quick display where it should be easy in sight)
  # angle = 0                     (no angle by default)
  # center_x/center_y = 0.5       (basically the center of the image will be drawn at x/y)
  # factor_x/factor_y = 1         (no zoom by default)
  # 
  @player = Player.new
  
  #
  # By default Chingu::Window calls update & draw on all GameObjects in it's own update/draw.
  # If this is not what you want, use :draw and :update
  #
  @player = Player.new(:draw => false, :update => false)

=== GameState / GameStateManager
Chingu incorporates a basic push/pop game state system (as discussed here: http://www.gamedev.net/community/forums/topic.asp?topic_id=477320).

Game states is a way of organizing your intros, menus, levels.

Game states aren't complicated. In Chingu a GameState is a class that behaves mostly like your default Gosu::Window (or in our case Chingu::Window) game loop.

  
  class Intro < Chingu::GameState
    def update
      # game logic here
    end
    
    def draw
      # screen manipulation here
    end
    
    def button_down(id)
      # called when a button is pressed
    end
    
    def finalize
      push_gamestate(Menu.new)  # Called when Intro dies for whatever reason.
    end
    
    # etc etc
  end

Looks familiar ye?
Active that game state/game loop in your main window (which is always the spider in the net).

  class Game < Chingu::Window
    def initialize
      push_gamestate(Intro.new)
    end
  end
  
A GameState in Chingu is just a class with the following instance methods: 

* setup()     - called when game state becomes active (switch_gamestate(gamestate) for example)
* button_down(id) - Called when a button is down
* button_up(id)   - Called when a button is released
* update()    - just as in your normal game loop, put your game logic here.
* draw()      - just as in your normal game loop, put your screen manipulation here.
* finalize()  - called when a game state is finished

Chingu::Window automatically creates a @game_state_manager and makes it accessible in our game loop.
By default the game loop calls update() / draw() on the the current game state.

Chingu also has a couple of helpers to easy change between game states.
In a main loop or in a game state:
* push_gamestate(state)     - adds a new gamestate, which then becomes the active one
* pop_gamestate             - removes active gamestate and activates the previous one
* switch_gamestate(state)   - pop all gamestates until given state is found

To switch to a certain gamestate with a keypress use Chingus keymapper:
  class Intro < Chingu::GameState
    def setup
      self.keymap = { :space => lambda{push_gamestate(Menu.new)} }
    end
  end
  
Or Chingus pretty shortcut:

  class Intro < Chingu::GameState
    def setup
      self.keymap = { :space => Menu }      #  { :space => Menu.new } works as well.
    end
  end

Chingu will detect that Menu is a gamestate-class and call push_gamestate on it when space is pressed inside Intro.

=== Assets / Paths

You might wonder why this is nessesary in the straight Gosu example:
  ROOT_PATH = File.dirname(File.expand_path(__FILE__))
  @image = Image.new(File.join(ROOT_PATH, "media", "player.png"))

It enables you to start your game from any directory and it will still find your assets (pictures, samples, fonts etc..) correctly.
For a local development version this might not be important, you're likely to start the game from the games root-dir.
But as soon as you try to deploy (for example to windows with OCRA - http://github.com/larsch/ocra/tree/master) you'll run into trouble of you dont do it like that.
 
Chingu solves this problem behind the scenes for the most common assets. The 2 lines above can be replaced with:
Image["player.png"]

You also have Sound["player.png"]

Tiles and fonts are trickier since they require extra parameters so you'll have to do those the ordinary way.
You'll get $window.root (equivalent to ROOT_PATH above) for free though which points to the dir containing the game.

=== Text
Text is a class to give the use of Gosu::Font more rubyish feel and fit it better into Chingu.

# Pure Gosu
  @font = Gosu::Font.new($window, "verdana", 30)
  @font.draw("A Text", 200, 50, 55, 2.0)
  
# Chingu
  @text = Chingu::Text.new(:text => "A Text", :x => 200, :y => 50, :zorder => 55, :factor_x => 2.0)
  @text.draw  # usually not needed as Text is a GameObject and therefore autodrawn

@text comes with a number of changeable properties, x,y,zorder,angle,factor_x,color,mode etc.


== TODO:
* (half done) Complete the keymap-definitions with all possible keys
* Complete keymap-stuff with released-states etc
* More gfx effects, for example: fade in/out to a specific color (black makes sense between levels).
* Summon good proven community gosu snippets into Chingu
* (done) Generate docs @ ippa.github.com-  http://rdoc.info/projects/ippa/chingu !
* (done) A good scene-manager to manage welcome screens, levels and game flow- GameStateManager / GameState !
* More docs
* (done) Make a gem- first gem made on github
* Automate gemgenning rake-task even more
* More examples when effects are more complete
* class ChipmunkObject
* class Actor/MovingActor with maybe abit more logic then the basic GameObject. Would ppl find is useful?
* Spell check all docs, sloppy spelling turns ppl off.
* Tests
* Streamline fps / tick code
* (done) Encapsulate Font.new / draw_rot with a "class Text < GameObject"
* Make it possible for ppl to use the parts of Chingu they like
* A more robust game state <-> game_object system to connect them together.
* Get better at styling rdocs
* all “gamestate” ? “game state” ?

== WHY?
* Plain Gosu is very minimalistic, perfect to build some higher level logic on!
* Deployment and asset handling should be simple
* Managing game states/scenes (intros, menus, levels etc) should be simple
* There are patterns in game development

== OPINIONS
* Less code is usually better
* Hash arguments FTW. And it becomes even better in 1.9.
* Don't separate too much from Gosus core-naming

== CREDITS:
Jacius of Rubygame (For doing cool stuff that's well documented as re-usable). So far rect.rb and named_resource.rb is taken from Rubygame.

jlnr,philymore,shawn24 for constructive feedback


== REQUIREMENTS:
* Gosu latest version
* Ruby 1.8 (Has not been verified with 1.9 yet)
